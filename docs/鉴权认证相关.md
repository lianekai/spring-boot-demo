CSRF（跨站请求伪造，Cross-Site Request Forgery）令牌牌是一种用于防御CSRF攻击的安全机制。
CSRF攻击是一种常见的网络攻击方式，攻击者通过诱导用户在已认证的会话中执行非本意的操作，例如在用户不知情的情况下执行转账、修改账户信息等操作。
CSRF令牌的作用主要包括以下几点：
1. 验证请求的合法性CSRF令牌用于验证发起请求的用户是否为合法用户，确保请求是由用户主动发起的，而不是由恶意网站或脚本伪造的。
2. 绑定用户会话每个用户的会话通常会生成一个唯一的CSRF令牌，这个令牌与用户的会话绑定，确保只有持有正确令牌的用户才能执行敏感操作。
3. 防止自动提交由于CSRF令牌通常需要用户主动从客户端提交，这可以防止自动提交表单，从而减少被攻击的风险。
4. 增强安全性通过在表单提交中加入CSRF令牌，可以增加攻击者伪造请求的难度，因为攻击者需要知道令牌的值才能成功发起请求。
5. 与同源策略互补CSRF令牌与同源策略（Same-Origin Policy）一起使用，可以更有效地防止跨站攻击。同源策略限制了从一个源加载的脚本如何与另一个源的资源进行交互，而CSRF令牌则确保了即使请求被发送到服务器，如果请求中不包含有效的令牌，服务器也会拒绝处理。
实现方式通常，CSRF令牌会以隐藏字段的形式加入到表单中，或者作为自定义HTTP头部发送。服务器在处理请求时会验证这个令牌是否有效。如果令牌无效或缺失，服务器将拒绝处理请求。示例在Web应用中，通常在用户登录后生成一个CSRF令牌，并将其存储在服务器的会话中。
同时，将这个令牌以隐藏字段的形式添加到所有需要保护的表单中。当表单被提交时，服务器会检查请求中的令牌是否与会话中存储的令牌匹配，如果不匹配，则拒绝处理请求。通过使用CSRF令牌，可以显著提高Web应用的安全性，防止恶意攻击者利用用户的认证会话执行未授权的操作。



在前后端分离的 Java + Vue 项目中，用户鉴权信息的存储方式主要有 Cookie、Session 和 Token（如 JWT）。以下是它们各自的优缺点和适用场景分析：
### 1. Cookie
#### 优点
• 自动携带：浏览器会自动将 Cookie 发送到服务器，无需前端手动处理。
• 简单易用：在传统的 Web 应用中，使用 Cookie 存储用户会话信息非常常见。
#### 缺点
• 安全性问题：Cookie 存储在客户端，容易被篡改或窃取，需要设置 HttpOnly 和 Secure 属性来增强安全性。
• 跨域限制：Cookie 是域名相关的，跨域时无法直接共享，需要额外配置。
• 大小限制：Cookie 的大小有限制（通常为 4KB 左右），不适合存储大量数据。适用场景• 如果项目对安全性要求不高，且主要在同域下操作，可以使用 Cookie 存储一些简单的鉴权信息（如用户登录状态）。

### 2. Session
#### 优点
• 安全性较高：Session 存储在服务器端，客户端只保存 Session ID，数据安全性较高。
• 易于管理：服务器端可以轻松管理 Session 的生命周期，例如设置超时时间。缺点
• 依赖服务器存储：Session 信息存储在服务器内存中，会占用服务器资源，不适合大规模分布式系统。
• 扩展性差：在分布式架构中，Session 需要共享，通常需要借助 Redis 等工具来实现，增加了复杂性。
• 跨域问题：Session 依赖 Cookie 来传递 Session ID，因此也存在跨域限制。
适用场景• 对于小型项目或单体应用，Session 是一个不错的选择。但如果项目是分布式架构，建议结合 Redis 等工具来管理 Session。

### 3. Token（如 JWT）
#### 优点
• 无状态、分布式友好：Token 存储在客户端，服务器无需存储用户会话信息，适合分布式系统。
• 跨域方便：Token 可以通过 HTTP 请求的 Header 传递，不受跨域限制。
• 安全性高：Token 可以通过签名和加密来保证数据的安全性和完整性。
• 自包含：Token 中可以包含用户信息（如用户 ID、角色等），减少服务器查询数据库的次数。
#### 缺点
• Token 无法直接失效：一旦 Token 发放给客户端，服务器无法直接使其失效（除非使用黑名单机制）。
• 大小问题：虽然 Token 本身比较小，但如果存储过多信息，也可能导致请求头过大。
• 需要管理 Token 的生命周期：需要合理设置 Token 的过期时间，并实现 Token 的刷新机制。适用场景
• 前后端分离的项目中，Token 是最常用的方式，尤其是 JWT。它适用于分布式架构、跨域场景，并且可以方便地实现无状态的用户认证。

综合建议对于前后端分离的 Java + Vue 项目，推荐使用 Token（如 JWT） 来处理用户鉴权信息，原因如下：
1. 无状态和分布式友好：前后端分离的项目通常采用微服务架构或分布式架构，Token 的无状态特性非常适合这种场景。
2. 跨域支持：在前后端分离的项目中，前端和后端通常运行在不同的域名或端口下，Token 可以通过 HTTP 请求头传递，不受跨域限制。
3. 安全性高：JWT 可以通过签名和加密来保证数据的安全性和完整性，同时可以存储一些必要的用户信息，减少服务器查询数据库的次数。
4. 易于实现：在 Java 和 Vue 中都有成熟的库来支持 JWT 的生成、解析和验证。
   
实现思路
### 后端（Java）
1. 生成 Token
• 使用 JWT 库（如   java-jwt   或   JJWT  ）生成 Token，包含用户 ID、角色等必要信息，并设置过期时间。
• 将 Token 返回给前端。
2. 验证 Token
• 在每个需要鉴权的接口中，从请求头中提取 Token。
• 验证 Token 的签名和过期时间，解析 Token 中的用户信息。
3. Token 刷新
• 如果 Token 过期，可以提供一个刷新接口，通过刷新 Token 来获取新的 Token。

### 前端（Vue）
1. 存储 Token
• 将 Token 存储在   localStorage   或   sessionStorage   中，方便在页面跳转时保持登录状态。• 不建议存储在 Cookie 中，因为 Token 的大小可能超过 Cookie 的限制。
2. 发送 Token
• 在每次发送请求时，从存储中获取 Token，并将其添加到请求头中（如   Authorization  ）。
3. 处理 Token 过期
• 如果后端返回 Token 过期的错误，前端可以提示用户重新登录或调用 Token 刷新接口。

## 示例代码
后端（Java）
```java
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;

import java.util.Date;

public class JwtUtil {
    private static final String SECRET_KEY = "your-secret-key"; // 密钥

    // 生成 Token
    public static String generateToken(String userId) {
        long nowMillis = System.currentTimeMillis();
        Date now = new Date(nowMillis);
        long expMillis = nowMillis + 3600000; // 设置 Token 有效期为 1 小时
        Date exp = new Date(expMillis);

        return Jwts.builder()
                .setSubject(userId) // 设置用户 ID
                .setIssuedAt(now) // 设置签发时间
                .setExpiration(exp) // 设置过期时间
                .signWith(SignatureAlgorithm.HS256, SECRET_KEY) // 设置签名算法和密钥
                .compact(); // 生成 Token
    }

    // 验证 Token
    public static String validateToken(String token) {
        try {
            return Jwts.parser()
                    .setSigningKey(SECRET_KEY)
                    .parseClaimsJws(token)
                    .getBody()
                    .getSubject(); // 获取用户 ID
        } catch (Exception e) {
            return null; // Token 验证失败
        }
    }
}
```

前端（Vue）
```javascript
// 存储 Token
localStorage.setItem('token', 'your-token');

// 发送请求时添加 Token
axios.interceptors.request.use(config => {
    const token = localStorage.getItem('token');
    if (token) {
        config.headers['Authorization'] = `Bearer ${token}`;
    }
    return config;
}, error => {
    return Promise.reject(error);
});

// 处理 Token 过期
axios.interceptors.response.use(response => {
    return response;
}, error => {
    if (error.response.status === 401) {
        // Token 过期，提示用户重新登录或刷新 Token
        alert('Token expired. Please login again.');
    }
    return Promise.reject(error);
});
```
